/// <reference lib="webworker" />
declare let self: ServiceWorkerGlobalScope;

import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

cleanupOutdatedCaches();

// Precache resources generated by build
precacheAndRoute(self.__WB_MANIFEST);

// Cache configurations from previous vite.config.ts
registerRoute(
    /^https:\/\/fonts\.googleapis\.com\/.*/i,
    new CacheFirst({
        cacheName: 'google-fonts-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 365,
            }),
        ],
    })
);

registerRoute(
    /^https:\/\/fonts\.gstatic\.com\/.*/i,
    new CacheFirst({
        cacheName: 'gstatic-fonts-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 365,
            }),
        ],
    })
);

registerRoute(
    /^https:\/\/unpkg\.com\/.*/i,
    new CacheFirst({
        cacheName: 'unpkg-libs-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 20,
                maxAgeSeconds: 60 * 60 * 24 * 365,
            }),
        ],
    })
);

registerRoute(
    /^https:\/\/mt1\.google\.com\/.*/i,
    new CacheFirst({
        cacheName: 'google-maps-tiles',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 500,
                maxAgeSeconds: 60 * 60 * 24 * 30,
            }),
        ],
    })
);

// Share Target Handler
// This manually handles the POST request from the Share Target API
self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);

    // Check for the share-target endpoint
    if (event.request.method === 'POST' && url.pathname === '/share-target') {
        event.respondWith(
            (async () => {
                try {
                    const formData = await event.request.formData();
                    const file = formData.get('routes'); // Must match the name in manifest

                    if (file && file instanceof File) {
                        // Open IDB to store the file
                        // We use raw IDB here because workbox doesn't expose a simple key-val for this
                        // and we want to avoid extra heavy dependencies in SW if possible.
                        // But to be safe and simple, we'll use a basic indexedDB open.
                        const dbReq = indexedDB.open('agromonitor-share', 1);

                        await new Promise<void>((resolve, reject) => {
                            dbReq.onupgradeneeded = (e: any) => {
                                const db = e.target.result;
                                if (!db.objectStoreNames.contains('shared_files')) {
                                    db.createObjectStore('shared_files');
                                }
                            };

                            dbReq.onsuccess = (e: any) => {
                                const db = e.target.result;
                                const tx = db.transaction('shared_files', 'readwrite');
                                const store = tx.objectStore('shared_files');
                                // Store with a known key we can retrieve in the app
                                store.put(file, 'latest_gpx');

                                tx.oncomplete = () => resolve();
                                tx.onerror = () => reject(tx.error);
                            };

                            dbReq.onerror = () => reject(dbReq.error);
                        });
                    }

                    // Redirect to the app with a query param to trigger processing
                    return Response.redirect('/?action=import_shared', 303);
                } catch (err) {
                    console.error('Share target error:', err);
                    // Fallback redirect even on error
                    return Response.redirect('/?error=share_failed', 303);
                }
            })()
        );
    }
});
